VIBE CODING RULES

enforceable:
(human should know, and agent should enforce)
1. I WILL MAKE SURE MY AGENT AFTER WRITING ANY CODE, RUNS THE PIPELINE, AND THE STATE SAYS IN A SYSTEM OF GREEN. 

2. I WILL STILL FOLLOW CONTINOUS IMPROVMENT OF THE SYSTEM, TESTABLE AND EVOLVEABLE. ANY CHANGE WILL HAVE TEST COVERAGE. 

3. MY SYSTEM WILL ALWAYS HAVE A SINGLE ATOMIC COMMAND TO PROVE CORRECTNESS OF SYSTEM. (so that LLM has minimal complexity for agent feedback loop) I SHOULD STRIVE TO ACHIEVE HIGH ACCURACY OF THIS CORRECTNESS, SO THAT I CAN BE RELIANT ON MY TESTS THAT SYSTEM IS PASSING.

4. MORE IS NOT ALWAYS BETTER, ANY CHANGE SHOULD BE BALANCED WITH THE TECH DEBT OF ADDING MORE COMPLEXITY.

5. I WILL ONLY EVOLVE MY SYSTEM, NOT CREATE SINGNIFICANTLY CHANGED COPIES. 

6. ISOLATE YOUR DAMN CONCERNS AND KEEP YOUR CONCERNS SEPERATED. AFTER ANY CHANGE MAKE SURE YOU CLEAN UP YOUR ABSTRACTION, SEPARATE CODE INTO FOLDERS, AND HIDE DETAIL BEHIND A CLEAN API SO THAT OUTWARDS COMPLEXITY SHOWN IS MINIMIZED. THEN, AFTER DOING THIS ALSO REVIEW THE GENERAL ARCHITCUTE OF THE COLLECTION OF THESE APIS, DOES THE ARCHITCTURE LEVEL MAKE SENSE, ARE THE APIS THE RIGHT BALANCE OF GENERalITY (TO BE USEFUL) BUT SPECIFICITY & MINIMALNESS TO BE CLEAN & MINIMIZE OUTWARDSLY SHOWN COMPLEXITY.

7. I WILL NOT OVERLOAD ONE CHAT HISTORY WITH MORE THAN ONE PROBLEM CONTEXT, AS SOON AS THIS HAPPENS I WILL WARN THE USER TO COMPRESS MY TRAJECTORY AND START  FRESH.

8. end every prompt with 
First confirm you understand this task, why we are doing it, and explore and think deeply to plan a good away to approach this problem before attacking it. 

9. please don’t create temporary files, even if they are .md explanations of your work. Update permanent documentation instead. 

human:
- I WILL STILL ENSURE MY SYSTEM IS A JOY TO WORK ON

- I WILL STILL KEEP COMMITS AND CHAT WINDOWS TO ONE TICKET WORTH EACH, IF I WANT TO WORK ON MORE THAN ONE COMMIT AT ONCE I WILL:

- WORK ON PARALLEL ON SEPERATE CLAUDE INSTANCES ON DIFFERENT BRANCHES IF WORKING IN PARALLEL

- I WILL KEEP MY PROMPTS TO A PROBABILITY OF >50% THAT IT WILL SUCCEED, SO I CAN BE CONFIDENT AND CHAIN BACKLOG OF PROMPTS IN THE CODE AGENT PIPELINE. IF IT IS LOWER THAN 50% THIS IS A SIGN THE COMPLEXITY IS GETTING TO LARGE FOR THIS LLM TO HANDLE.

- ALWAYS REVIEW THE AGENTS WORK UNLESS YOU CAN BE ABSOLUTELY CERTAIN THE ABSTRACTION INWARDS ARE WITHIN THE COMPLEXITY RANGE OF WHAT AN LLM CAN EASIBLY SOLVe.

- I WILL KEEP MY CONTEXT I INPUT TO THE LLM MINIMIZED TO ONLY WHAT IS ESSENTIAL, AS MORE AND MORE BECOMES IRRELEVANT, I WILL COMPRESS MY CONTEXT TO RELEVANCy.

- I WILL CONTINUE TO REMEMBER MY TERMINAL COMMANDS, AND COMPUTER TOOL BASICS. I can forget the intricacies of my language, that’s fine, as long as I spend an equivalent amount of that time learning higher order concepts such as system architecture. 

- minimize complexity by hiding multiple required steps behind a single atomic action the llm can run e.g. llm_setup bash script 